/*
 * 10.1
 * В базе данных Redis подберите коллекцию для подсчета 
 * посещений с определенных IP-адресов.
 */

/*
 * Возможно я не очень поняла задание.. Можно использовать множества:
 * Ключом будет IP-адрес, значением будет множество из дат посещений
 * Командой SCARD <IP-адрес> можно получить количество записей в множестве, т.е количество посещений
 */

-- Добавляем значение в базу командой SADD:
SADD 0.0.0.0 '2019-07-21 00:00:00' '2019-07-21 00:00:01' '2019-07-21 00:00:02' '2019-07-21 00:00:03'
SADD 1.1.1.1 '2019-07-21 00:00:10' '2019-07-21 00:00:11'
-- Смотрим количество посещений для конкретного IP-адреса командой SCARD:
SCARD 0.0.0.0 -- (integer) 4
SCARD 1.1.1.1 -- (integer) 2

/*
 * Можно использовать обычный ключ и целочисленное значение, которое увеличивать с каждым посещением
 */

-- Сначала задаем нулевые значения количества посещений
SET 0.0.0.0 0
SET 1.1.1.1 0
-- Затем, с каждым посещением инкрементируем счетчик
INCR 0.0.0.0
-- Смотрим количество посещений для конкретного IP-адреса
GET 0.0.0.0 -- '1'
GET 1.1.1.1 -- '0'

/*
 * 10.2
 * При помощи базы данных Redis решите задачу поиска 
 * имени пользователя по электронному адресу и наоборот, 
 * поиск электронного адреса пользователя по его имени.
 */

/*
 * Используем хэш, значения добавляем в следующем виде:
 * основной ключ: <имя пользователя>:<электронный адрес>
 * ключи хэша: user_name и email
 */

-- Добавляем данные в базу
HMSET user1:email1@domen.ru user_name user1 email email1@domen.ru
HMSET user2:email2@domen.ru user_name user2 email email2@domen.ru
-- Ищем имя пользователя по электронному адресу
KEYS *:email1@domen.ru -- 1) "user1:email1@domen.ru"
-- Ищем электронный адрес по имени пользователя
KEYS user1:* -- 1) "user1:email1@domen.ru"
-- Если ответ в форме <имя пользователя>:<электронный адрес> не устраивает, то 
-- следующим шагом отдельно вытаскиваем имя пользователя или электронную почту по полученному ключу
HGET user1:email1@domen.ru user_name -- "user1"
HGET user1:email1@domen.ru email -- "email1@domen.ru"

/*
 * 10.3
 * Организуйте хранение категорий и товарных позиций учебной базы данных shop в СУБД MongoDB.
 */

-- Организуем хранение одной коллекцией со следующей структурой
/*
{
   _id: catalog_id
   name: catalog_name, -- 'Название категории'
   products: [ 
      {
         id: product_id,
         name:  product_name, -- 'Название товарной позиции'
         description: product_description, -- 'Описание товарной позиции'
         price: product_price, -- 'Цена товарной позиции'
         created_at: product_created_at,
         updated_at: product_updated_at
      },
      {
         id: product_id,
         name:  product_name, -- 'Название товарной позиции'
         description: product_description, -- 'Описание товарной позиции'
         price: product_price, -- 'Цена товарной позиции'
         created_at: product_created_at,
         updated_at: product_updated_at
      }
   ]
}
*/
-- Заполняем коллекцию в бд
use shop
db.shop.insert({ name: 'Материнские платы' })
db.shop.insert({ name: 'Видеокарты' })
db.shop.insert({ name: 'Жесткие диски' })
db.shop.insert({ name: 'Оперативная память' })
db.shop.insert({ name: 'Процессоры' })

-- Сморим, что получилось
db.shop.find() 
/*
{ "_id" : ObjectId("5d34bc0a733666748235331f"), "name" : "Материнские платы" }
{ "_id" : ObjectId("5d34d31b7336667482353320"), "name" : "Видеокарты" }
{ "_id" : ObjectId("5d34d31b7336667482353321"), "name" : "Жесткие диски" }
{ "_id" : ObjectId("5d34d31b7336667482353322"), "name" : "Оперативная память" }
{ "_id" : ObjectId("5d34d31d7336667482353323"), "name" : "Процессоры" }
 */

-- Добавляем товарные позиции
db.shop.update({ name: 'Материнские платы' }, 
{
   $set :
   {
      products: 
      [
         { 
            id : 1, 
            name : 'MSI B250M GAMING PRO',
            description : 'Материнская плата MSI B250M GAMING PRO, B250, Socket 1151, DDR4, mATX',
            price : 5060.00,
            created_at : '2019-07-17 02:14:03',
            updated_at : '2019-07-17 02:14:03'
         }
      ] 
   }
})

db.shop.update({ name: 'Материнские платы' }, 
{
   $push :
   {
      products: 
      { 
            id : 2, 
            name : 'Gigabyte H310M S2H',
            description : 'Материнская плата Gigabyte H310M S2H, H310, Socket 1151-V2, DDR4, mATX',
            price : 4790.00,
            created_at : '2019-07-17 02:14:03',
            updated_at : '2019-07-17 02:14:03'
      } 
   }
})

db.shop.update({ name: 'Процессоры' }, 
{
   $set :
   {
      products: 
      [
         { 
            id : 1, 
            name : 'AMD FX-8320',
            description : 'Процессор для настольных персональных компьютеров, основанных на платформе AMD.',
            price : 7120.00,
            created_at : '2019-07-17 02:14:03',
            updated_at : '2019-07-17 02:14:03'
         }
      ] 
   }
})

-- По запросу  db.shop.find({"name" : "Материнские платы"}).pretty() получаем результат:
/*
{
   "_id" : ObjectId("5d34bc0a733666748235331f"),
   "name" : "Материнские платы",
   "products" : [
      {
         "id" : 1,
         "name" : "MSI B250M GAMING PRO",
         "description" : "Материнская плата MSI B250M GAMING PRO, B250, Socket 1151, DDR4, mATX",
         "price" : 5060,
         "created_at" : "2019-07-17 02:14:03",
         "updated_at" : "2019-07-17 02:14:03"
      },
      {
         "id" : 2,
         "name" : "Gigabyte H310M S2H",
         "description" : "Материнская плата Gigabyte H310M S2H, H310, Socket 1151-V2, DDR4, mATX",
         "price" : 4790,
         "created_at" : "2019-07-17 02:14:03",
         "updated_at" : "2019-07-17 02:14:03"
      }
   ]
}
*/
-- По запросу  db.shop.find({"name" : "Процессоры"}).pretty() получаем результат:
/*
{
   "_id" : ObjectId("5d34d31d7336667482353323"),
   "name" : "Процессоры",
   "products" : [
      {
         "id" : 1,
         "name" : "AMD FX-8320",
         "description" : "Процессор для настольных персональных компьютеров, основанных на платформе AMD.",
         "price" : 7120,
         "created_at" : "2019-07-17 02:14:03",
         "updated_at" : "2019-07-17 02:14:03"
      }
   ]
}
*/
-- И т.д. Заполняем каталог, добавляя товарные позиции в соответствующую категорию


-- Пример запроса информации из такой структуры:
-- Выводим категорию, наименования и цены всех продуктов, цена которых больше 7000
db.shop.find({"products.price": {$gt:7000}}, {"name": 1, "products.name": 1, "products.price": 1}).pretty()
-- Результат:
/*
{
   "_id" : ObjectId("5d34d31d7336667482353323"),
   "name" : "Процессоры",
   "products" : [
      {
         "name" : "AMD FX-8320",
         "price" : 7120
      }
   ]
}
*/
